#!/usr/bin/env node
/**
 * Runner de migrações neutro (SQLite/PG) para o projeto LATE.
 * - Identificadores em inglês; comentários/erros em pt-BR.
 * - Usa o DB Manager (config/database.js) e aplica os .sql em migrations/ por ordem.
 * - Registra em schema_migrations (filename PRIMARY KEY).
 * - Em PG: transação por arquivo; em SQLite: exec direto.
 * - Em SQLite: adapta automaticamente "GENERATED BY DEFAULT AS IDENTITY" -> "INTEGER PRIMARY KEY".
 *
 * Uso:
 *   node scripts/migrate.js            # aplica pendentes
 *   node scripts/migrate.js --dry-run  # só lista
 */

const fs = require('fs');
const path = require('path');
const dbManager = require('../config/database');

const MIGRATIONS_DIR = path.join(__dirname, '..', 'migrations');
const MIGRATIONS_TABLE = 'schema_migrations';
const isDryRun = process.argv.includes('--dry-run');

function listSqlFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  return fs
    .readdirSync(dir)
    .filter(f => f.toLowerCase().endsWith('.sql'))
    .sort((a, b) => a.localeCompare(b, 'en', { numeric: true }));
}

function transformSqlForDriver(sqlText, driver) {
  if (driver !== 'sqlite') return sqlText;

  // SQLite não entende "GENERATED BY DEFAULT AS IDENTITY".
  // Troca linhas típicas de PK com identidade por "INTEGER PRIMARY KEY".
  // Casos cobertos: "id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY"
  //                 "id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY"
  const identityRegex =
    /\bid\s+INTEGER\s+PRIMARY\s+KEY\s+GENERATED\s+(?:BY\s+DEFAULT|ALWAYS)\s+AS\s+IDENTITY\b/gi;

  let out = sqlText.replace(identityRegex, 'id INTEGER PRIMARY KEY');

  // TIMESTAMP é aceito por SQLite, mas se quiser pode mapear para DATETIME.
  // Aqui mantemos, pois DEFAULT CURRENT_TIMESTAMP funciona para ambos.

  return out;
}

async function ensureMigrationsTable(db, driver) {
  const sql =
    driver === 'pg'
      ? `
        CREATE TABLE IF NOT EXISTS ${MIGRATIONS_TABLE} (
          filename TEXT PRIMARY KEY,
          applied_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        );
      `
      : `
        CREATE TABLE IF NOT EXISTS ${MIGRATIONS_TABLE} (
          filename TEXT PRIMARY KEY,
          applied_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
        );
      `;
  await db.exec(sql);
}

async function getApplied(db) {
  try {
    const stmt = db.prepare(`SELECT filename FROM ${MIGRATIONS_TABLE} ORDER BY filename ASC`);
    const rows = await stmt.all();
    return new Set((rows || []).map(r => r.filename));
  } catch (e) {
    return new Set();
  }
}

async function markApplied(db, filename) {
  const stmt = db.prepare(`INSERT INTO ${MIGRATIONS_TABLE} (filename) VALUES (${dbManager.placeholder(1)})`);
  await stmt.run([filename]);
}

async function applyFileTransactional(adapter, filename, sqlText) {
  const driver = adapter.name;
  const transformed = transformSqlForDriver(sqlText, driver);

  if (driver === 'pg') {
    return dbManager.transaction(async (db) => {
      await db.exec(transformed);
    });
  } else {
    const db = dbManager.getDatabase();
    await db.exec(transformed);
  }
}

(async function main() {
  const adapter = dbManager.adapter(); // seleciona driver via DB_DRIVER
  const driver = adapter.name;
  const db = dbManager.getDatabase();

  const files = listSqlFiles(MIGRATIONS_DIR);
  if (files.length === 0) {
    console.info('[migrate] Nenhum arquivo .sql encontrado em migrations/.');
    await dbManager.close();
    process.exit(0);
  }

  try {
    await ensureMigrationsTable(db, driver);
  } catch (e) {
    console.error('[migrate] ERRO ao garantir tabela de migrações:', e.message);
    await dbManager.close();
    process.exit(1);
  }

  const applied = await getApplied(db);
  const pendentes = files.filter(f => !applied.has(f));

  if (pendentes.length === 0) {
    console.info('[migrate] Não há migrações pendentes.');
    await dbManager.close();
    process.exit(0);
  }

  console.info(`[migrate] Driver ativo: ${driver}`);
  console.info('[migrate] Arquivos pendentes:', pendentes);

  if (isDryRun) {
    console.info('[migrate] Modo --dry-run: nenhuma migração será aplicada.');
    await dbManager.close();
    process.exit(0);
  }

  for (const fname of pendentes) {
    const full = path.join(MIGRATIONS_DIR, fname);
    const sqlText = fs.readFileSync(full, 'utf8');
    console.info(`[migrate] Aplicando: ${fname} ...`);
    try {
      await applyFileTransactional(adapter, fname, sqlText);
      await markApplied(db, fname);
      console.info(`[migrate] OK: ${fname}`);
    } catch (err) {
      console.error(`[migrate] ERRO ao aplicar ${fname}:`, err.message);
      await dbManager.close();
      process.exit(1);
    }
  }

  await dbManager.close();
  console.info('[migrate] Concluído com sucesso.');
  process.exit(0);
})().catch(async (e) => {
  console.error('[migrate] Falha inesperada:', e);
  try { await dbManager.close(); } catch {}
  process.exit(1);
});
