process.env.NODE_ENV = 'test';

const { newDb } = require('pg-mem');

jest.mock('../middleware/csrf', () => jest.fn((_req, _res, next) => next()));

let dbPool;
let messageController;

function bootstrapDatabase() {
  const mem = newDb({ autoCreateForeignKeyIndices: true });
  mem.public.registerFunction({
    name: 'gen_random_uuid',
    returns: 'uuid',
    implementation: () => require('crypto').randomUUID(),
  });

  const adapter = mem.adapters.createPg();
  global.__LATE_POOL_FACTORY = () => new adapter.Pool();
  jest.resetModules();

  dbPool = require('../config/database');
  messageController = require('../controllers/messageController');
}

async function createSchema() {
  await dbPool.query(`
    CREATE TABLE users (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT,
      email TEXT,
      password_hash TEXT,
      role TEXT DEFAULT 'ADMIN',
      is_active BOOLEAN DEFAULT TRUE,
      view_scope TEXT DEFAULT 'all',
      session_version INTEGER DEFAULT 1,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE messages (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      call_date TEXT,
      call_time TEXT,
      recipient TEXT,
      recipient_user_id INTEGER,
      recipient_sector_id INTEGER,
      sender_name TEXT,
      sender_phone TEXT,
      sender_email TEXT,
      subject TEXT,
      message TEXT,
      status TEXT DEFAULT 'pending',
      visibility TEXT DEFAULT 'private',
      callback_at TIMESTAMPTZ,
      notes TEXT,
      parent_message_id INTEGER,
      created_by INTEGER,
      updated_by INTEGER,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE message_comments (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      message_id INTEGER REFERENCES messages(id) ON DELETE CASCADE,
      user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
      body TEXT NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE message_events (
      id SERIAL PRIMARY KEY,
      message_id INTEGER REFERENCES messages(id) ON DELETE CASCADE,
      event_type TEXT,
      payload JSONB,
      created_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE event_logs (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      event_type TEXT NOT NULL,
      entity_type TEXT NOT NULL,
      entity_id TEXT NOT NULL,
      actor_user_id INTEGER,
      metadata JSONB,
      created_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE sectors (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT,
      email TEXT,
      is_active BOOLEAN DEFAULT TRUE
    );

    CREATE TABLE user_sectors (
      user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
      sector_id INTEGER REFERENCES sectors(id) ON DELETE CASCADE,
      PRIMARY KEY (user_id, sector_id)
    );
  `);

  await dbPool.query(`
    INSERT INTO users (id, name, email, role, is_active)
    VALUES (1, 'Admin LATE', 'admin@late.dev', 'ADMIN', TRUE);

    INSERT INTO messages (id, subject, message, status, created_by, updated_by)
    VALUES (1, 'Primeiro registro', 'Conteúdo inicial', 'pending', 1, 1);
  `);
}

function buildReqRes({ status, resolutionComment }) {
  const req = {
    params: { id: '1' },
    body: { status },
    session: {
      user: {
        id: 1,
        name: 'Admin LATE',
        role: 'ADMIN',
      },
    },
  };

  if (resolutionComment !== undefined) {
    req.body.resolutionComment = resolutionComment;
  }

  const res = {
    statusCode: 200,
    payload: null,
    status(code) {
      this.statusCode = code;
      return this;
    },
    json(body) {
      this.payload = body;
      return this;
    },
  };

  return { req, res };
}

describe('Mensagem - follow-up obrigatório ao resolver', () => {
  beforeAll(async () => {
    bootstrapDatabase();
    await createSchema();
  });

  afterAll(async () => {
    await dbPool.close?.();
    delete global.__LATE_POOL_FACTORY;
  });

  it('retorna 400 ao tentar resolver sem comentário', async () => {
    const { req, res } = buildReqRes({ status: 'resolved' });

    await messageController.updateStatus(req, res);

    expect(res.statusCode).toBe(400);
    expect(res.payload?.success).toBe(false);

    const { rows } = await dbPool.query('SELECT status FROM messages WHERE id = $1', [1]);
    expect(rows[0].status).toBe('pending');
  });

  it('resolve com comentário obrigatório e registra auditoria', async () => {
    const { req, res } = buildReqRes({
      status: 'resolved',
      resolutionComment: 'Ticket solucionado via contato telefônico.',
    });

    await messageController.updateStatus(req, res);

    expect(res.statusCode).toBe(200);
    expect(res.payload?.success).toBe(true);

    const [{ status }] = (await dbPool.query('SELECT status FROM messages WHERE id = $1', [1])).rows;
    expect(status).toBe('resolved');

    const commentResult = await dbPool.query('SELECT body FROM message_comments WHERE message_id = $1', [1]);
    expect(commentResult.rowCount).toBe(1);

    const logs = await dbPool.query('SELECT event_type FROM event_logs');
    const eventTypes = logs.rows.map((row) => row.event_type);
    expect(eventTypes).toContain('message.status_changed');
    expect(eventTypes).toContain('comment.created');
  });
});
