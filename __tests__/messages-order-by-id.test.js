const request = require('supertest');
const express = require('express');
const { newDb } = require('pg-mem');

let dbManager;
let app;

function setupDatabase() {
  const mem = newDb({ autoCreateForeignKeyIndices: true });
  const adapter = mem.adapters.createPg();
  global.__LATE_POOL_FACTORY = () => new adapter.Pool();
  jest.resetModules();
  dbManager = require('../config/database');
}

async function ensureSchema() {
  const db = dbManager.getDatabase();

  await db.exec('DROP TABLE IF EXISTS user_sectors CASCADE;');
  await db.exec('DROP TABLE IF EXISTS users CASCADE;');
  await db.exec('DROP TABLE IF EXISTS sectors CASCADE;');
  await db.exec('DROP TABLE IF EXISTS messages CASCADE;');

  await db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT NOT NULL,
      email TEXT,
      password_hash TEXT,
      role TEXT NOT NULL DEFAULT 'OPERADOR',
      is_active BOOLEAN NOT NULL DEFAULT TRUE,
      view_scope TEXT DEFAULT 'all',
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);

  await db.exec(`
    CREATE TABLE IF NOT EXISTS sectors (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT NOT NULL,
      email TEXT,
      is_active BOOLEAN NOT NULL DEFAULT TRUE,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);

  await db.exec(`
    CREATE TABLE IF NOT EXISTS user_sectors (
      user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      sector_id INTEGER NOT NULL REFERENCES sectors(id) ON DELETE CASCADE,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (user_id, sector_id)
    );
  `);

  await db.exec(`
    CREATE TABLE IF NOT EXISTS messages (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      call_date TEXT,
      call_time TEXT,
      recipient TEXT,
      recipient_user_id INTEGER,
      recipient_sector_id INTEGER,
      sender_name TEXT,
      sender_phone TEXT,
      sender_email TEXT,
      subject TEXT,
      message TEXT,
      status TEXT,
      visibility TEXT NOT NULL DEFAULT 'private',
      callback_time TEXT,
      notes TEXT,
      created_by INTEGER,
      updated_by INTEGER,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);

  const valuePlaceholders = Array.from({ length: 13 }, (_, index) => dbManager.placeholder(index + 1)).join(', ');

  const insert = db.prepare(`
    INSERT INTO messages (
      call_date, call_time, recipient, sender_name,
      sender_phone, sender_email, subject, message,
      status, callback_time, notes, created_by, updated_by, created_at, updated_at
    ) VALUES (${valuePlaceholders}, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    RETURNING id
  `);

  await db.exec(`
    INSERT INTO users (id, name, role, is_active) VALUES
      (1, 'Test User', 'ADMIN', TRUE)
    ON CONFLICT (id) DO NOTHING;
  `);

  await insert.get(['2025-01-01', '09:00', 'Equipe A', 'JoÃ£o', null, null, 'Aviso', 'Mensagem 1', 'pending', null, null, 1, 1]);
  await insert.get(['2025-01-02', '10:30', 'Equipe B', 'Maria', null, null, 'Aviso', 'Mensagem 2', 'resolved', null, null, 1, 1]);
}

beforeAll(async () => {
  setupDatabase();
  await ensureSchema();

  const apiRoutes = require('../routes/api');
  app = express();
  app.use(express.json());
  app.use((req, _res, next) => {
    req.session = {
      user: {
        id: 1,
        name: 'Test User',
        role: 'ADMIN',
      },
    };
    next();
  });
  app.use('/api', apiRoutes);
});

afterAll(async () => {
  await dbManager.close();
  jest.resetModules();
  delete global.__LATE_POOL_FACTORY;
});

test('orders messages by id descending', async () => {
  const res = await request(app).get('/api/messages');
  expect(res.status).toBe(200);
  expect(res.body.success).toBe(true);
  const ids = res.body.data.map(m => m.id);
  expect(ids).toEqual([2, 1]);
});
