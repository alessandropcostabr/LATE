process.env.NODE_ENV = 'test';

const express = require('express');
const request = require('supertest');
const { newDb } = require('pg-mem');
const { hashToken } = require('../utils/hashToken');

jest.mock('../services/emailQueue', () => ({
  enqueueTemplate: jest.fn().mockResolvedValue(null),
}));

jest.mock('../middleware/csrf', () => jest.fn((_req, _res, next) => next()));

let emailQueue;

function createDatabase() {
  const mem = newDb({ autoCreateForeignKeyIndices: true });
  mem.public.registerFunction({ name: 'gen_random_uuid', returns: 'uuid', implementation: () => require('crypto').randomUUID() });
  const adapter = mem.adapters.createPg();
  global.__LATE_POOL_FACTORY = () => new adapter.Pool();
  jest.resetModules();
  const dbManager = require('../config/database');
  return { mem, dbManager };
}

async function bootstrapSchema(db) {
  await db.exec(`
    CREATE TABLE users (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT,
      email TEXT,
      password_hash TEXT,
      role TEXT DEFAULT 'OPERADOR',
      is_active BOOLEAN DEFAULT TRUE,
      view_scope TEXT DEFAULT 'all',
      session_version INTEGER NOT NULL DEFAULT 1,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE sectors (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT,
      email TEXT,
      is_active BOOLEAN DEFAULT TRUE
    );

    CREATE TABLE user_sectors (
      user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
      sector_id INTEGER REFERENCES sectors(id) ON DELETE CASCADE,
      PRIMARY KEY (user_id, sector_id)
    );

    CREATE TABLE messages (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      call_date TEXT,
      call_time TEXT,
      recipient TEXT,
      recipient_user_id INTEGER,
      recipient_sector_id INTEGER,
      sender_name TEXT,
      sender_phone TEXT,
      sender_email TEXT,
      subject TEXT,
      message TEXT,
      status TEXT DEFAULT 'pending',
      visibility TEXT DEFAULT 'private',
      callback_at TIMESTAMPTZ,
      notes TEXT,
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE message_events (
      id SERIAL PRIMARY KEY,
      message_id INTEGER REFERENCES messages(id) ON DELETE CASCADE,
      event_type TEXT,
      payload JSONB,
      created_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE email_queue (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      to_email TEXT NOT NULL,
      subject TEXT NOT NULL,
      body_json JSONB NOT NULL,
      status TEXT NOT NULL,
      attempts INT NOT NULL DEFAULT 0,
      next_run_at TIMESTAMPTZ,
      last_error TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE intake_logs (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      message_id INTEGER REFERENCES messages(id) ON DELETE SET NULL,
      token_hash TEXT,
      payload JSONB,
      ip TEXT,
      user_agent TEXT,
      status TEXT NOT NULL,
      error TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);
}

function createApp(dbManager, sessionUser = null) {
  const app = express();
  app.use(express.json());
  app.use((req, _res, next) => {
    if (sessionUser) {
      const version = Number(sessionUser.sessionVersion || 1);
      req.session = {
        user: {
          ...sessionUser,
          sessionVersion: version,
        },
        sessionVersion: version,
        destroy: (cb) => (typeof cb === 'function' ? cb() : undefined),
        cookie: {},
      };
    } else {
      req.session = {};
    }
    next();
  });
  const apiRoutes = require('../routes/api');
  app.use('/api', apiRoutes);
  return app;
}

describe('POST /api/intake', () => {
  const originalToken = process.env.INTAKE_TOKEN;
  let dbManager;

  beforeEach(async () => {
    process.env.INTAKE_TOKEN = 'secret-token';
    process.env.INTAKE_TOKEN_PEPPER = 'pepper-test';
    const setup = createDatabase();
    dbManager = setup.dbManager;
    await bootstrapSchema(dbManager.getDatabase());
    emailQueue = require('../services/emailQueue');
    emailQueue.enqueueTemplate.mockClear();
  });

  afterEach(async () => {
    await dbManager.close();
    jest.resetModules();
    delete global.__LATE_POOL_FACTORY;
    process.env.INTAKE_TOKEN = originalToken;
    delete process.env.INTAKE_TOKEN_PEPPER;
    delete process.env.INTAKE_TOKEN_EXPIRES_AT;
    emailQueue = null;
  });

  test('cria registro via intake e registra log', async () => {
    const database = dbManager.getDatabase();
    await database.exec(`
      INSERT INTO users (id, name, email) VALUES (10, 'Atendente', 'atendente@example.com');
    `);

    const app = createApp(dbManager);

    const response = await request(app)
      .post('/api/intake')
      .set('x-intake-token', 'secret-token')
      .send({
        subject: 'Registro via intake',
        message: 'Detalhes do registro',
        recipientUserId: 10,
      });

    expect(response.status).toBe(201);
    expect(response.body).toMatchObject({ success: true, data: { id: expect.any(Number) } });
    expect(emailQueue.enqueueTemplate).toHaveBeenCalled();

    const { rows } = await database.query('SELECT * FROM messages');
    expect(rows).toHaveLength(1);
    expect(rows[0].recipient_user_id).toBe(10);
    expect(rows[0].status).toBe('pending');

    const logRows = await database.query('SELECT status, token_hash FROM intake_logs');
    expect(logRows.rows).toEqual([
      { status: 'success', token_hash: hashToken('secret-token') }
    ]);
  });

  test('recusa token inválido', async () => {
    const database = dbManager.getDatabase();
    const app = createApp(dbManager);
    const response = await request(app)
      .post('/api/intake')
      .set('x-intake-token', 'wrong')
      .send({ subject: 'Teste', message: 'Mensagem', recipientUserId: 1 });

    expect(response.status).toBe(401);
    expect(emailQueue.enqueueTemplate).not.toHaveBeenCalled();

    const { rows } = await database.query('SELECT status, token_hash FROM intake_logs');
    expect(rows).toEqual([
      { status: 'unauthorized', token_hash: hashToken('wrong') }
    ]);
  });

  test('expira token conforme configuração', async () => {
    process.env.INTAKE_TOKEN_EXPIRES_AT = '2020-01-01T00:00:00Z';
    const database = dbManager.getDatabase();
    const app = createApp(dbManager);

    const response = await request(app)
      .post('/api/intake')
      .set('x-intake-token', 'secret-token')
      .send({ subject: 'Teste', message: 'Mensagem', recipientUserId: 1 });

    expect(response.status).toBe(401);
    const { rows } = await database.query('SELECT status, token_hash, error FROM intake_logs');
    expect(rows).toEqual([
      {
        status: 'unauthorized',
        token_hash: hashToken('secret-token'),
        error: 'Token expirado',
      },
    ]);
  });

  test('valida campos obrigatórios', async () => {
    const database = dbManager.getDatabase();
    const app = createApp(dbManager);
    const response = await request(app)
      .post('/api/intake')
      .set('x-intake-token', 'secret-token')
      .send({ subject: '', message: '', recipientUserId: null });

    expect(response.status).toBe(400);
    expect(response.body.success).toBe(false);
    expect(emailQueue.enqueueTemplate).not.toHaveBeenCalled();

    const { rows } = await database.query('SELECT status, token_hash FROM intake_logs');
    expect(rows).toEqual([
      { status: 'error', token_hash: hashToken('secret-token') }
    ]);
  });
});
