process.env.NODE_ENV = 'test';

const express = require('express');
const request = require('supertest');
const { newDb } = require('pg-mem');

jest.mock('../services/emailQueue', () => ({
  enqueueTemplate: jest.fn().mockResolvedValue(null),
}));

jest.mock('../middleware/csrf', () => jest.fn((_req, _res, next) => next()));

let enqueueTemplate;

function createDatabase() {
  const mem = newDb({ autoCreateForeignKeyIndices: true });
  const adapter = mem.adapters.createPg();
  global.__LATE_POOL_FACTORY = () => new adapter.Pool();
  jest.resetModules();
  const dbManager = require('../config/database');
  return { mem, adapter, dbManager };
}

async function bootstrapSchema({ mem, db }) {
  mem.public.registerFunction({
    name: 'trim',
    args: ['text'],
    returns: 'text',
    implementation: (value) => {
      if (value === null || value === undefined) return null;
      return String(value).trim();
    },
  });

  mem.public.registerFunction({
    name: 'nullif',
    args: ['text', 'text'],
    returns: 'text',
    implementation: (a, b) => {
      if (a === null || a === undefined) return null;
      if (b === null || b === undefined) return String(a);
      const left = String(a);
      const right = String(b);
      return left === right ? null : left;
    },
  });
  mem.public.registerFunction({
    name: 'gen_random_uuid',
    returns: 'uuid',
    implementation: () => require('crypto').randomUUID(),
  });

  await db.exec('DROP TABLE IF EXISTS user_sectors CASCADE;');
  await db.exec('DROP TABLE IF EXISTS messages CASCADE;');
  await db.exec('DROP TABLE IF EXISTS users CASCADE;');
  await db.exec('DROP TABLE IF EXISTS sectors CASCADE;');
  await db.exec('DROP TABLE IF EXISTS message_events CASCADE;');
  await db.exec('DROP TABLE IF EXISTS event_logs CASCADE;');

  await db.exec(`
    CREATE TABLE users (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT NOT NULL,
      email TEXT,
      password_hash TEXT,
      role TEXT NOT NULL DEFAULT 'OPERADOR',
      is_active BOOLEAN NOT NULL DEFAULT TRUE,
      allow_offsite_access BOOLEAN NOT NULL DEFAULT TRUE,
      access_restrictions JSONB NOT NULL DEFAULT '{}'::jsonb,
      view_scope TEXT DEFAULT 'all',
      session_version INTEGER NOT NULL DEFAULT 1,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);

  await db.exec(`
    CREATE TABLE sectors (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      name TEXT NOT NULL,
      email TEXT,
      is_active BOOLEAN NOT NULL DEFAULT TRUE,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);

  await db.exec(`
    CREATE TABLE user_sectors (
      user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      sector_id INTEGER NOT NULL REFERENCES sectors(id) ON DELETE CASCADE,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (user_id, sector_id)
    );
  `);

  await db.exec(`
    CREATE TABLE messages (
      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      call_date TEXT,
      call_time TEXT,
      recipient TEXT,
      recipient_user_id INTEGER,
      recipient_sector_id INTEGER,
      sender_name TEXT,
      sender_phone TEXT,
      sender_email TEXT,
      subject TEXT,
      message TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      visibility TEXT NOT NULL DEFAULT 'private',
      callback_at TIMESTAMPTZ,
      notes TEXT,
      created_by INTEGER,
      updated_by INTEGER,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);

  await db.exec(`
    CREATE TABLE message_events (
      id SERIAL PRIMARY KEY,
      message_id INTEGER NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
      event_type TEXT NOT NULL,
      payload JSONB,
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    );
  `);

  await db.exec(`
    CREATE TABLE event_logs (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      event_type TEXT NOT NULL,
      entity_type TEXT NOT NULL,
      entity_id TEXT NOT NULL,
      actor_user_id INTEGER,
      metadata JSONB,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);
}

function createApp(sessionUser) {
  const app = express();
  app.use(express.json());
  app.use((req, _res, next) => {
    req.session = {
      user: { ...sessionUser, sessionVersion: 1 },
      sessionVersion: 1,
      destroy: jest.fn((cb) => cb?.()),
      cookie: {},
    };
    next();
  });

  const apiRoutes = require('../routes/api');
  app.use('/api', apiRoutes);
  return app;
}

describe('Mensagens direcionadas a setor', () => {
  let dbManager;
  let database;

  beforeEach(async () => {
    const setup = createDatabase();
    dbManager = setup.dbManager;
    database = dbManager.getDatabase();
    await bootstrapSchema({ mem: setup.mem, db: database });
    enqueueTemplate = require('../services/emailQueue').enqueueTemplate;
    enqueueTemplate.mockClear();
  });

  afterEach(async () => {
    await dbManager.close();
    jest.resetModules();
    delete global.__LATE_POOL_FACTORY;
  });

  test('envia e-mail para todos os usuários ativos do setor ao criar recado', async () => {
    await database.exec(`
      INSERT INTO users (id, name, email, role) VALUES
        (1, 'Alice', 'alice@example.com', 'OPERADOR'),
        (2, 'Bruno', 'bruno@example.com', 'OPERADOR'),
        (99, 'Admin', 'admin@example.com', 'ADMIN');

      INSERT INTO sectors (id, name) VALUES (10, 'Suporte');

      INSERT INTO user_sectors (user_id, sector_id) VALUES
        (1, 10),
        (2, 10);
    `);

    const app = createApp({ id: 99, name: 'Admin', role: 'ADMIN' });

    const response = await request(app)
      .post('/api/messages')
      .send({
        call_date: '2025-01-01',
        call_time: '08:30',
        recipientType: 'sector',
        recipientSectorId: 10,
        sender_name: 'Cliente',
        subject: 'Suporte urgente',
        message: 'Preciso de ajuda com o sistema.',
      });

    expect(response.status).toBe(201);
    expect(response.body.success).toBe(true);
    expect(enqueueTemplate).toHaveBeenCalledTimes(2);
    const recipients = enqueueTemplate.mock.calls.map((call) => call[0]?.to).sort();
    expect(recipients).toEqual(['alice@example.com', 'bruno@example.com']);
  });

  test('quando membro do setor assume recado altera destinatário para o usuário', async () => {
    await database.exec(`
      INSERT INTO users (id, name, email, role) VALUES
        (1, 'Setorista', 'setorista@example.com', 'OPERADOR');

      INSERT INTO sectors (id, name) VALUES (10, 'Suporte');

      INSERT INTO user_sectors (user_id, sector_id) VALUES (1, 10);

      INSERT INTO messages (
        id, call_date, call_time, recipient, recipient_sector_id,
        sender_name, subject, message, status, visibility
      ) VALUES (
        1, '2025-01-01', '09:00', 'Suporte', 10,
        'Cliente', 'Dúvida', 'Mensagem inicial', 'pending', 'private'
      );
    `);

    const app = createApp({ id: 1, name: 'Setorista', role: 'OPERADOR' });

    enqueueTemplate.mockClear();

    const response = await request(app)
      .patch('/api/messages/1/status')
      .send({ status: 'in_progress' });

    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.data.recipient_user_id).toBe(1);
    expect(response.body.data.recipient_sector_id).toBeNull();

    const { rows } = await database.query('SELECT recipient_user_id, recipient_sector_id FROM messages WHERE id = 1');
    expect(rows[0].recipient_user_id).toBe(1);
    expect(rows[0].recipient_sector_id).toBeNull();
    expect(enqueueTemplate).not.toHaveBeenCalled();
  });
});
