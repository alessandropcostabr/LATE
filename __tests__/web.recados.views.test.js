const path = require('path');
const express = require('express');
const supertest = require('supertest');
const { JSDOM } = require('jsdom');
const { newDb } = require('pg-mem');

const { normalizeRoleSlug, hasPermission } = require('../middleware/auth');

jest.mock('../middleware/csrf', () => jest.fn((req, _res, next) => next()));

describe('Sprint B · Vistas Kanban e Calendário', () => {
  let mem;
  let dbManager;

  beforeEach(async () => {
    ({ mem, dbManager } = setupDatabase());
    await bootstrapSchema(mem);
    await seedBaseData(mem);
  });

  afterEach(async () => {
    if (dbManager?.close) {
      await dbManager.close();
    }
    jest.resetModules();
    delete global.__LATE_POOL_FACTORY;
  });

  test('kanban exibe apenas recados do usuário quando o escopo é own', async () => {
    const app = createApp({
      id: 1,
      name: 'Ana Operadora',
      role: 'OPERADOR',
      viewScope: 'own',
    });

    const response = await supertest(app).get('/recados/kanban');
    expect(response.status).toBe(200);

    const dom = new JSDOM(response.text);
    const titles = Array.from(dom.window.document.querySelectorAll('.kanban-card__title'))
      .map((el) => el.textContent.trim());

    expect(titles).toContain('Retorno Ana');
    expect(titles).not.toContain('Retorno Bruno');
    expect(titles).not.toContain('Atendimento Setorial');
  });

  test('kanban lista somente labels visíveis ao operador com escopo own', async () => {
    const app = createApp({
      id: 1,
      name: 'Ana Operadora',
      role: 'OPERADOR',
      viewScope: 'own',
    });

    const response = await supertest(app).get('/recados/kanban');
    expect(response.status).toBe(200);

    const dom = new JSDOM(response.text);
    const labels = Array.from(
      dom.window.document.querySelectorAll('select[name="label"] option')
    )
      .map((option) => option.value.trim())
      .filter(Boolean);

    expect(labels).toContain('priority');
    expect(labels).not.toContain('followup');
  });

  test('calendário aplica filtro de label corretamente', async () => {
    const app = createApp({
      id: 99,
      name: 'Admin',
      role: 'ADMIN',
      viewScope: 'all',
    });

    const response = await supertest(app).get('/recados/calendario?label=priority');
    expect(response.status).toBe(200);

    const dom = new JSDOM(response.text);
    const rows = Array.from(dom.window.document.querySelectorAll('table tbody tr'));
    const subjects = rows
      .map((row) => row.querySelector('td:nth-child(2) strong')?.textContent?.trim())
      .filter(Boolean);

    expect(subjects).toContain('Retorno Ana');
    expect(subjects).not.toContain('Retorno Bruno');
    expect(subjects).not.toContain('Atendimento Setorial');
  });

  function setupDatabase() {
    const memInstance = newDb({ autoCreateForeignKeyIndices: true });
    const adapter = memInstance.adapters.createPg();
    global.__LATE_POOL_FACTORY = () => new adapter.Pool();
    jest.resetModules();
    const db = require('../config/database');
    return { mem: memInstance, dbManager: db };
  }

  async function bootstrapSchema(memInstance) {
    const db = memInstance.public;

    db.registerFunction({
      name: 'trim',
      args: ['text'],
      returns: 'text',
      implementation: (value) => {
        if (value === null || value === undefined) return null;
        return String(value).trim();
      },
    });

    db.registerFunction({
      name: 'round',
      args: ['numeric'],
      returns: 'numeric',
      implementation: (value) => {
        if (value === null || value === undefined) return null;
        return Math.round(Number(value));
      },
    });

    db.none('DROP TABLE IF EXISTS message_checklist_items CASCADE;');
    db.none('DROP TABLE IF EXISTS message_checklists CASCADE;');
    db.none('DROP TABLE IF EXISTS message_labels CASCADE;');
    db.none('DROP TABLE IF EXISTS user_sectors CASCADE;');
    db.none('DROP TABLE IF EXISTS messages CASCADE;');
    db.none('DROP TABLE IF EXISTS sectors CASCADE;');
    db.none('DROP TABLE IF EXISTS users CASCADE;');

    db.none(`
      CREATE TABLE users (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        name TEXT NOT NULL,
        email TEXT,
        password_hash TEXT,
        role TEXT NOT NULL DEFAULT 'OPERADOR',
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        view_scope TEXT DEFAULT 'all',
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);

    db.none(`
      CREATE TABLE sectors (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        name TEXT NOT NULL,
        email TEXT,
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);

    db.none(`
      CREATE TABLE user_sectors (
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        sector_id INTEGER NOT NULL REFERENCES sectors(id) ON DELETE CASCADE,
        PRIMARY KEY (user_id, sector_id)
      );
    `);

    db.none(`
      CREATE TABLE messages (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        call_date TEXT,
        call_time TEXT,
        recipient TEXT,
        recipient_user_id INTEGER,
        recipient_sector_id INTEGER,
        sender_name TEXT,
        sender_phone TEXT,
        sender_email TEXT,
        subject TEXT,
        message TEXT,
        status TEXT,
        visibility TEXT DEFAULT 'private',
        callback_time TEXT,
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        created_by INTEGER,
        updated_by INTEGER
      );
    `);

    db.none(`
      CREATE TABLE message_labels (
        message_id INTEGER REFERENCES messages(id) ON DELETE CASCADE,
        label TEXT NOT NULL,
        PRIMARY KEY (message_id, label)
      );
    `);

    db.none(`
      CREATE TABLE message_checklists (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        message_id INTEGER NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
        title TEXT,
        progress_cached SMALLINT NOT NULL DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);

    db.none(`
      CREATE TABLE message_checklist_items (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        checklist_id INTEGER NOT NULL REFERENCES message_checklists(id) ON DELETE CASCADE,
        title TEXT,
        done BOOLEAN DEFAULT FALSE,
        position INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);
  }

  async function seedBaseData(memInstance) {
    const db = memInstance.public;

    db.none(`
      INSERT INTO users (id, name, email, role, is_active, view_scope)
      VALUES
        (1, 'Ana Operadora', 'ana@example.com', 'OPERADOR', TRUE, 'own'),
        (2, 'Bruno Operador', 'bruno@example.com', 'OPERADOR', TRUE, 'all'),
        (99, 'Admin', 'admin@example.com', 'ADMIN', TRUE, 'all')
    `);

    db.none(`
      INSERT INTO sectors (id, name, email, is_active)
      VALUES (1, 'Atendimento', 'atendimento@example.com', TRUE)
    `);

    db.none(`
      INSERT INTO messages (
        id, call_date, call_time, recipient, recipient_user_id, recipient_sector_id,
        subject, message, status, visibility, callback_time, created_at, updated_at
      ) VALUES
        (1, '2025-01-15', '09:00', 'Ana Operadora', 1, NULL,
         'Retorno Ana', 'Detalhes 1', 'pending', 'private', '14:00', NOW(), NOW()),
        (2, '2025-01-16', '10:30', 'Bruno Operador', 2, NULL,
         'Retorno Bruno', 'Detalhes 2', 'pending', 'private', '15:00', NOW(), NOW()),
        (3, '2025-01-17', '11:00', 'Setor Atendimento', NULL, 1,
         'Atendimento Setorial', 'Detalhes 3', 'in_progress', 'private', '16:00', NOW(), NOW());
    `);

    db.none(`
      INSERT INTO message_labels (message_id, label)
      VALUES
        (1, 'priority'),
        (3, 'followup')
    `);
  }

  function createApp(sessionUser) {
    const app = express();
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, '..', 'views'));
    app.locals.cssFile = '/css/style.min.css';

    app.use((req, res, next) => {
      req.session = { user: sessionUser };
      const roleSlug = normalizeRoleSlug(sessionUser.role);
      res.locals.user = sessionUser;
      res.locals.userRoleSlug = roleSlug;
      res.locals.permissions = {
        readMessages: hasPermission(roleSlug, 'read'),
        createMessages: hasPermission(roleSlug, 'create'),
        updateMessages: hasPermission(roleSlug, 'update'),
        deleteMessages: hasPermission(roleSlug, 'delete'),
      };
      next();
    });

    const webRoutes = require('../routes/web');
    app.use(webRoutes);
    return app;
  }
});
