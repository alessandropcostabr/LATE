const { newDb } = require('pg-mem');

function setupDatabase() {
  const mem = newDb({ autoCreateForeignKeyIndices: true });
  const adapter = mem.adapters.createPg();

  global.__LATE_POOL_FACTORY = () => new adapter.Pool();
  jest.resetModules();

  const dbManager = require('../config/database');
  const MessageModel = require('../models/message');

  return { dbManager, MessageModel };
}

describe('messages ownership metadata', () => {
  let dbManager;
  let MessageModel;

  beforeEach(async () => {
    ({ dbManager, MessageModel } = setupDatabase());
    const db = dbManager.getDatabase();

    await db.exec('DROP TABLE IF EXISTS messages CASCADE;');
    await db.exec(`
      CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        call_date TEXT,
        call_time TEXT,
        recipient TEXT,
        recipient_user_id INTEGER,
        recipient_sector_id INTEGER,
        sender_name TEXT,
        sender_phone TEXT,
        sender_email TEXT,
        subject TEXT,
        message TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        visibility TEXT NOT NULL DEFAULT 'private',
        callback_time TEXT,
        notes TEXT,
        created_by INTEGER,
        updated_by INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);

    await db.exec(`
      CREATE TABLE IF NOT EXISTS user_sectors (
        user_id INTEGER,
        sector_id INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);
  });

  afterEach(async () => {
    await dbManager.close();
    jest.resetModules();
    delete global.__LATE_POOL_FACTORY;
  });

  test('persists created_by e updated_by corretamente', async () => {
    const messageId = await MessageModel.create({
      recipient: 'Equipe Suporte',
      subject: 'Teste de autoria',
      message: 'OlÃ¡ mundo',
      created_by: 42,
      updated_by: 42,
    });

    const created = await MessageModel.findById(messageId);
    expect(created.created_by).toBe(42);
    expect(created.updated_by).toBe(42);

    const visibleForOwner = await MessageModel.list({ viewer: { id: 42, viewScope: 'own' } });
    const visibleIds = visibleForOwner.map((item) => item.id);
    expect(visibleIds).toContain(messageId);

    const invisibleToOthers = await MessageModel.list({ viewer: { id: 99, viewScope: 'own' } });
    expect(invisibleToOthers.find((item) => item.id === messageId)).toBeUndefined();

    await MessageModel.update(messageId, {
      message: 'Mensagem editada',
      updated_by: 77,
    });

    const updated = await MessageModel.findById(messageId);
    expect(updated.created_by).toBe(42);
    expect(updated.updated_by).toBe(77);

    await MessageModel.updateStatus(messageId, 'resolved', { updatedBy: 99 });

    const resolved = await MessageModel.findById(messageId);
    expect(resolved.status).toBe('resolved');
    expect(resolved.updated_by).toBe(99);
  });
});
