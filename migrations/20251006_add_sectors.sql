-- migrations/20251006_add_sectors.sql
-- Cria as tabelas "sectors" e "user_sectors" + índices e gatilhos de integridade.
-- Postgres only.

BEGIN;

-- =========================
-- 1) Tabela: sectors
-- =========================
CREATE TABLE IF NOT EXISTS sectors (
  id          INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  -- Nome obrigatório, sem somente espaços e com no máximo 120 chars
  name        TEXT NOT NULL CHECK (btrim(name) <> '' AND char_length(name) <= 120),
  -- E-mail opcional; se informado, no máximo 254 chars
  email       TEXT CHECK (char_length(email) <= 254),
  is_active   BOOLEAN NOT NULL DEFAULT TRUE,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Unicidade case-insensitive
CREATE UNIQUE INDEX IF NOT EXISTS uniq_sectors_name_ci  ON sectors (LOWER(name));
CREATE UNIQUE INDEX IF NOT EXISTS uniq_sectors_email_ci ON sectors (LOWER(email)) WHERE email IS NOT NULL;

-- Atualização de updated_at
CREATE OR REPLACE FUNCTION set_sectors_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sectors_set_updated ON sectors;
CREATE TRIGGER trg_sectors_set_updated
BEFORE UPDATE ON sectors
FOR EACH ROW
EXECUTE FUNCTION set_sectors_updated_at();


-- =========================
-- 2) Tabela de junção: user_sectors (N:N)
-- =========================
CREATE TABLE IF NOT EXISTS user_sectors (
  user_id     INTEGER NOT NULL,
  sector_id   INTEGER NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (user_id, sector_id),
  CONSTRAINT fk_user_sectors_user
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE RESTRICT,
  CONSTRAINT fk_user_sectors_sector
    FOREIGN KEY (sector_id) REFERENCES sectors(id) ON DELETE RESTRICT
);

-- Índices auxiliares para performance
CREATE INDEX IF NOT EXISTS idx_user_sectors_user   ON user_sectors(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sectors_sector ON user_sectors(sector_id);


-- =========================
-- 3) Gatilhos de integridade "mínimo 1" (DEFERRABLE)
--    Garantem:
--    - Cada usuário deve permanecer com ≥ 1 setor
--    - Cada setor deve permanecer com ≥ 1 usuário
--    Observação: DEFERRABLE INITIALLY DEFERRED => avaliados no COMMIT
-- =========================

-- Usuário: mínimo 1 setor
CREATE OR REPLACE FUNCTION check_user_min_one_sector()
RETURNS TRIGGER AS $$
DECLARE
  v_user_id INTEGER;
BEGIN
  v_user_id := COALESCE(NEW.user_id, OLD.user_id);

  IF NOT EXISTS (SELECT 1 FROM user_sectors us WHERE us.user_id = v_user_id) THEN
    RAISE EXCEPTION 'Usuário precisa estar associado a pelo menos um setor'
      USING ERRCODE = '23514'; -- check_violation
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Setor: mínimo 1 usuário
CREATE OR REPLACE FUNCTION check_sector_min_one_user()
RETURNS TRIGGER AS $$
DECLARE
  v_sector_id INTEGER;
BEGIN
  v_sector_id := COALESCE(NEW.sector_id, OLD.sector_id);

  IF NOT EXISTS (SELECT 1 FROM user_sectors us WHERE us.sector_id = v_sector_id) THEN
    RAISE EXCEPTION 'Setor precisa ter pelo menos um usuário'
      USING ERRCODE = '23514';
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Triggers como CONSTRAINT TRIGGER DEFERRABLE (avaliados no COMMIT)
DROP TRIGGER IF EXISTS trg_user_min_one_sector ON user_sectors;
CREATE CONSTRAINT TRIGGER trg_user_min_one_sector
AFTER INSERT OR DELETE ON user_sectors
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION check_user_min_one_sector();

DROP TRIGGER IF EXISTS trg_sector_min_one_user ON user_sectors;
CREATE CONSTRAINT TRIGGER trg_sector_min_one_user
AFTER INSERT OR DELETE ON user_sectors
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION check_sector_min_one_user();

COMMIT;

